#
#    ICRAR - International Centre for Radio Astronomy Research
#    (c) UWA - The University of Western Australia, 2017
#    Copyright by UWA (in the framework of the ICRAR)
#    All rights reserved
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
#    MA 02111-1307  USA
#
"""
This module defines the fields each drop takes for each reproducibility standard defined.
Consider this module partially documentation, partially code.
Data generated by instanced drops at runtime are defined with that drop's implementation.
"""

from enum import Enum

from dlg.common import Categories, STORAGE_TYPES, APP_DROP_TYPES
from dlg.common.reproducibility.constants import ReproducibilityFlags


class FieldOps(Enum):
    """
    Defines the operations possible on drop data for provenance collection.
    """
    STORE = 0
    COUNT = 1
    REMOVE_FIRST = 2  # Removes the first char of an assumed string


def extract_fields(drop: dict, fields: dict):
    """
    Attempts to extract fields with the names in fields from the drop description.
    If not found, the key will not be present in the returned dictionary.
    """
    data = {}
    for key, op in fields.items():
        if drop.get(key) is not None:
            if op == FieldOps.STORE:
                data[key] = drop.get(key)
            elif op == FieldOps.COUNT:
                data[key] = len(drop.get(key))
            elif op == FieldOps.REMOVE_FIRST:
                data[key] = drop.get(key)[1:]
    return data


def lgt_block_fields(rmode: ReproducibilityFlags):
    if rmode == ReproducibilityFlags.NOTHING:
        return {}
    data = {'categoryType': FieldOps.STORE, 'category': FieldOps.STORE,
            'inputPorts': FieldOps.COUNT, 'outputPorts': FieldOps.COUNT,
            'streaming': FieldOps.STORE}
    if rmode == ReproducibilityFlags.REPRODUCE:
        del data['inputPorts']
        del data['outputPorts']
        del data['streaming']
    return data


def lg_block_fields(category: Categories, category_type: str, rmode: ReproducibilityFlags):
    data = {}
    if rmode in (
            ReproducibilityFlags.NOTHING, ReproducibilityFlags.RERUN,
            ReproducibilityFlags.REPRODUCE, ReproducibilityFlags.REPLICATE_SCI):
        return data
    # Drop category considerations
    if category == "Application":
        data['execution_time'] = FieldOps.STORE
        data['num_cpus'] = FieldOps.STORE
    elif category == "Group":
        data['inputApplicationName'] = FieldOps.STORE
        data['inputApplicationType'] = FieldOps.STORE
    elif category == Categories.DATA:  # An anomaly, I know
        data['data_volume'] = FieldOps.STORE

    # Drop type considerations
    if category_type == Categories.START:
        pass
    elif category_type == Categories.END:
        pass
    elif category_type == Categories.MEMORY:
        pass
    elif category_type == Categories.SHMEM:
        pass
    elif category_type == Categories.FILE:
        data['check_filepath_exists'] = FieldOps.STORE
        if rmode in (ReproducibilityFlags.RECOMPUTE, ReproducibilityFlags.REPLICATE_COMP):
            data['filepath'] = FieldOps.STORE
            data['dirname'] = FieldOps.STORE
    elif category_type == Categories.NULL:
        pass
    elif category_type == Categories.JSON:
        pass
    elif category_type == Categories.NGAS:
        pass
    elif category_type == Categories.S3:
        pass
    elif category_type == Categories.PLASMA:
        # TODO: Investigate Plasma fields
        pass
    elif category_type == Categories.PLASMAFLIGHT:
        # TODO: Investigate PlasmaFlight Fields
        pass
    elif category_type == Categories.PARSET:
        # TODO: Workout how to absorb all fields
        pass
    elif category_type == Categories.ENVIRONMENTVARS:
        pass
    elif category_type == Categories.MKN:
        # TODO: Investigate MKN fields
        pass
    elif category_type == Categories.SCATTER:
        data['num_of_copies'] = FieldOps.STORE
        data['scatter_axis'] = FieldOps.STORE
    elif category_type == Categories.GATHER:
        data['num_of_inputs'] = FieldOps.STORE
        data['gather_axis'] = FieldOps.STORE
    elif category_type == Categories.LOOP:
        data['num_of_iter'] = FieldOps.STORE
    elif category_type == Categories.GROUP_BY:
        data['group_key'] = FieldOps.STORE
        data['group_axis'] = FieldOps.STORE
    elif category_type == Categories.VARIABLES:
        pass
    elif category_type == Categories.BRANCH:
        # TODO: Investigate branch fields
        pass
    elif category_type == Categories.PYTHON_APP:
        pass
    elif category_type == Categories.COMPONENT:
        data['appclass'] = FieldOps.STORE
    elif category_type == Categories.BASH_SHELL_APP:
        data['Arg01'] = FieldOps.STORE
    elif category_type == Categories.MPI:
        data['num_of_procs'] = FieldOps.STORE
    elif category_type == Categories.DOCKER:
        data['image'] = FieldOps.STORE
        data['command'] = FieldOps.STORE
        data['user'] = FieldOps.STORE
        data['ensureUserAndSwitch'] = FieldOps.STORE
        data['removeContainer'] = FieldOps.STORE
        data['additionalBindings'] = FieldOps.STORE
    elif category_type == Categories.DYNLIB_APP:
        data['libpath'] = FieldOps.STORE
    elif category_type == Categories.DYNLIB_PROC_APP:
        data['libpath'] = FieldOps.STORE
    return data


def pgt_unroll_block_fields(category_type, rmode: ReproducibilityFlags):
    data = {}
    if rmode == ReproducibilityFlags.NOTHING:
        return data
    if rmode != ReproducibilityFlags.NOTHING:
        data['type'] = FieldOps.STORE
    if rmode != ReproducibilityFlags.REPRODUCE:
        if category_type != 'plain':
            data['dt'] = FieldOps.STORE
    if category_type == 'plain':
        data['storage'] = FieldOps.STORE
    if rmode in (ReproducibilityFlags.RECOMPUTE, ReproducibilityFlags.REPLICATE_COMP):
        data['rank'] = FieldOps.STORE

    return data


def pgt_partition_block_fields(rmode: ReproducibilityFlags):
    data = {}
    if rmode in (ReproducibilityFlags.RECOMPUTE, ReproducibilityFlags.REPLICATE_COMP):
        data['node'] = FieldOps.REMOVE_FIRST
        data['island'] = FieldOps.REMOVE_FIRST
    return data


def pg_block_fields(rmode: ReproducibilityFlags):
    # These two happen to have the same data.
    data = {}
    if rmode in (ReproducibilityFlags.RECOMPUTE, ReproducibilityFlags.REPLICATE_COMP):
        data['node'] = FieldOps.STORE
        data['island'] = FieldOps.STORE
    return data
