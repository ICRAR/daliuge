<!doctype html>

<meta charset="utf-8">
<title>Physical graph {{pg_name}}</title>

<script src="/static/d3/d3.v3.min.js" charset="utf-8"></script>
<script src="/static/d3/dagre-d3.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script type="text/javascript">

/*
$(document).load(function(){
  $('#blabla').click(function(){
  alert("Clicked");
  });
});
*/

/*
trigger the socket listener
*/
function trigger_sl(host, port_number) {
    $.get("/trigger_sl?port_number=" + port_number.toString() + "&listen_host=" + host, function(data, status){
      //alert("Data: " + data + "\nStatus: " + status);
      alert(data)
    });
}
</script>

<style>

  body {
    position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    margin: 0;
    padding: 0;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
    background: #fff;
  }


  @-webkit-keyframes flash {
    0%, 50%, 100% {
      opacity: 1;
    }

    25%, 75% {
      opacity: 0.2;
    }
  }

  @keyframes flash {
    0%, 50%, 100% {
      opacity: 1;
    }

    25%, 75% {
      opacity: 0.2;
    }
  }

  .warn {
    -webkit-animation-duration: 5s;
    animation-duration: 5s;
    -webkit-animation-fill-mode: both;
    animation-fill-mode: both;
    -webkit-animation-iteration-count: 1;
    animation-iteration-count: 1;
  }

  .live.map {
    width: 100%;
    height: 100%;
  }

  svg {
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  .live.map text {
    font-weight: 200;
    font-size: 10px;
  }

  .live.map .node rect {
    stroke-width: 2.0px;
    stroke: #bbb;
    fill: #fff;
  }

   .live.map .node parallelogram {
    stroke-width: 2.0px;
    stroke: #bbb;
    fill: #fff;
  }

  .live.map .node circle {
    stroke-width: 2.0px;
    stroke: #bbb;
    fill: #fff;
  }


  .live.map .status {
    height: 100%;
    width: 0px;
    display: block;
    float: left;
    border-top-left-radius: 1px;
    border-bottom-left-radius: 1px;
    margin-right: 1px;
  }

  .live.map .allocated .status {
    background-color: #7f7;
  }

  .live.map .container .status {
    background-color: #ffed68;
  }

  .live.map .allocated.warn .status {
    background-color: #ffed68;
  }

  .live.map .stopped .status {
    /* background-color: #700000; */
    background-color: #b2b2b2; /* grey */

  }

  .live.map .warn .queue {
    color: #f77;
  }

  .warn {
    -webkit-animation-name: flash;
    animation-name: flash;
  }

  .live.map .loc {
    margin-right: 2px;
  }

  .live.map .loc,
  .live.map .name {
    margin-top: 1px;
  }

  .live.map .loc:after {
    content: "";
  }

  .live.map .queue {
    display: block;
    float: left;
    width: 130px;
    height: 20px;
    font-size: 10px;
    margin-top: 2px;
  }

  .live.map .node g div {
    width: 180px;
    height: 40px;
    color: #000;
  }

  .live.map .node g div span.loc {
    display: inline-block;
    width: 20px;
  }

  .live.map .edgeLabel text {
    width: 50px;
    fill: #fff;
  }

  .live.map .edgePath path {
    stroke: #999;
    stroke-width: 1.5px;
    fill: #999;
  }
</style>

<body>
<div>
	<a href="/">All graphs</a>
	<a href="jsonbody?pg_name={{pg_name}}" target="_blank">See JSON body</a>
	<a href="execute?pg_name={{pg_name}}" target="_blank">Execute with Luigi</a>
  <a href="show?pg_name={{pg_name}}&pg_layout={{pg_rotate}}">Rotate the graph</a>
</div>
<div class="live map">
  <svg><g/></svg>
</div>

<script>
  /*
  var xmlhttp = new XMLHttpRequest();
  var url = "http://localhost:8081/jsonbody?pg_name=container";
  var workers;
  xmlhttp.onreadystatechange = function() {
    if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
        workers = JSON.parse(xmlhttp.responseText);
        //get_worker(myArr);
    }
  }

  xmlhttp.open("GET", url, true);
  xmlhttp.send();
  */
  //var workers = {"Obj-D": {"loc": "192.168.1.2:7777", "inputQueue": [{"oid": "Obj-C"}], "type": 1}, "Obj-one": {"loc": "192.168.1.1:7777", "type": 4}, "Obj-A": {"loc": "192.168.1.1:7777", "inputQueue": [{"oid": "Obj-one"}], "type": 4}, "Obj-C": {"loc": "192.168.1.2:7777", "inputQueue": [{"oid": "Obj-A"}, {"oid": "Obj-B"}], "type": 2}, "Obj-B": {"loc": "192.168.1.1:7777", "inputQueue": [{"oid": "Obj-one"}], "type": 4}};
  var workers = {{!json_workers}}
  /*
  var workers = {
    "identifier": {
      "loc": 2,
      "type": 20
    },
    "lost-and-found": {
      "loc": 1,
      "type": 1,
      "inputQueue": "identifier",
      "inputThroughput": 50
    },
    "monitor": {
      "loc": 1,
      "type": 0,
      "inputQueue": "identifier",
      "inputThroughput": 50
    },
    "meta-enricher": {
      "loc": 4,
      "type": 9900,
      "inputQueue": "identifier",
      "inputThroughput": 50
    },
    "geo-enricher": {
      "loc": 2,
      "type": 1,
      "inputQueue": "meta-enricher",
      "inputThroughput": 50
    },
    "elasticsearch-writer": {
      "loc": 0,
      "type": 9900,
      "inputQueue": "geo-enricher",
      "inputThroughput": 50
    }
  }; */

  // Set up zoom support
  var svg = d3.select("svg"),
      inner = svg.select("g"),
      zoom = d3.behavior.zoom().on("zoom", function() {
        inner.attr("transform", "translate(" + d3.event.translate + ")" +
                                    "scale(" + d3.event.scale + ")");
      });
  svg.call(zoom);

  var render = new dagreD3.render();

  // Left-to-right layout
  var g = new dagreD3.graphlib.Graph();
  g.setGraph({
    nodesep: 70,
    ranksep: 50,
    rankdir: "{{!pg_layout}}",
    marginx: 20,
    marginy: 20
  });

  function draw(isUpdate) {
    for (var id in workers) {
      var worker = workers[id];
      var className;
      var fill_color;
      var pad_gap;
      switch(worker.type) {
        case 3:
          className = "warn"; /* socket listener data obj */
          node_shape = "parallelogram";
          fill_color = "#b2b2b2"
          pad_gap = 1;
          break
        case 2:
          className = "container";
          node_shape = "parallelogram";
          fill_color = "#ffed68"
          pad_gap = 1;
          break;
        case 1:
          className = "stopped"; /* normal data obj*/
          node_shape = "parallelogram";
          fill_color = "#FFFFFF"
          pad_gap = 0;
          break;
        default:
          className = "allocated" /* app data obj */
          node_shape = "rect"
          fill_color = "#afa"
          pad_gap = 0;
      }
      /*
      var className = worker.loc ? "allocated" : "stopped";
      if (worker.type > 10000) {
        className += " warn";
      }
      */
      var html = "<div style=\"text-align: center;\">";
      html += "<span class=status></span><span class=name>";
      var id_str = id
      if (3 == worker.type) {
        id_str +=  " <a href=\"#\" onclick=\"trigger_sl(" + "'" + worker.host + "', " + worker.port.toString() + ")\">ingest</a>"
      }
      html += id_str + "</span>";
      html += "<br/>"
      html += "<span class=name>" + "@" + worker.loc + "</span>";
      //html += "<span class=name>" + id + "</span>";
      //html += "<span class=queue><span class=counter>"+worker.type+"</span></span>";
      html += "</div>";

      g.setNode(id, {
        labelType: "html",
        label: html,
        rx: 3,
        ry: 3,
        shape: node_shape,
        style: "fill: " + fill_color + "; stroke: #bbb; stroke-width: 2.0px;"
        /* class: className */
      });


      if (worker.inputQueue) {
        var i;
        for (i = 0; i < worker.inputQueue.length; i++) {
            g.setEdge(worker.inputQueue[i].oid, id, {
            label: "",
            width: 40
          });
        }

      }
    }

    // Add our custom shape (parallelogram, similar to the PIP PDR document)
    render.shapes().parallelogram = function(parent, bbox, node) {
    var w = bbox.width,
        h = bbox.height,
        points = [
          { x:   0, y:        -h * 0.2  },
          { x:   w * 0.9, y:        -h * 0.2  },
          { x:   w * 0.9 + w/9, y:       -h * 1.1 },
          { x: w/9, y: -h * 1.1},
        ];
        shapeSvg = parent.insert("polygon", ":first-child")
          .attr("points", points.map(function(d) { return d.x + "," + d.y; }).join(" "))
          .attr("transform", "translate(" + (-w/2) + "," + (h * 3/4) + ")");

    node.intersect = function(point) {
      return dagreD3.intersect.polygon(node, points, point);
    };

    return shapeSvg;
    };

    inner.call(render, g);

    // Zoom and scale to fit
    var zoomScale = zoom.scale();
    var graphWidth = g.graph().width + 80;
    var graphHeight = g.graph().height + 40;
    var width = parseInt(svg.style("width").replace(/px/, ""));
    var height = parseInt(svg.style("height").replace(/px/, ""));
    zoomScale = Math.min(width / graphWidth, height / graphHeight);
    var translate = [(width/2) - ((graphWidth*zoomScale)/2), (height/2) - ((graphHeight*zoomScale)/2)];
    zoom.translate(translate);
    zoom.scale(zoomScale);
    zoom.event(isUpdate ? svg.transition().duration(500) : d3.select("svg"));
  }

  // Do some mock queue status updates
  /*
  setInterval(function() {
    var stoppedWorker1Count = workers["elasticsearch-writer"].type;
    var stoppedWorker2Count = workers["meta-enricher"].type;
    for (var id in workers) {
      workers[id].type = Math.ceil(Math.random() * 3);
      if (workers[id].inputThroughput) workers[id].inputThroughput = Math.ceil(Math.random() * 250);
    }
    workers["elasticsearch-writer"].type = stoppedWorker1type + Math.ceil(Math.random() * 100);
    workers["meta-enricher"].type = stoppedWorker2Count + Math.ceil(Math.random() * 100);
    draw(true);
  }, 1000);

  // Do a mock change of worker configuration
  setInterval(function() {
    workers["elasticsearch-monitor"] = {
      "loc": 0,
      "type": 0,
      "inputQueue": "elasticsearch-writer",
      "inputThroughput": 50
    }
  }, 5000);
  */

  draw();
</script>
